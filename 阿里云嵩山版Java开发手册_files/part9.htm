<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>(六) 集合处理</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part8.htm">&lt; 上一个</a><span> | </span><a href="../阿里云嵩山版Java开发手册.html">内容</a><span> | </span><a href="part10.htm">下一个 &gt;</a></p><p class="s16" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark8">(六) 集合处理</a><a name="bookmark20">&zwnj;</a></p><p class="s9" style="padding-top: 4pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">1. <span style=" color: #C00000;">【强制】</span>关于 hashCode 和 equals 的处理，遵循如下规则：</p><p style="padding-left: 42pt;text-indent: 0pt;text-align: left;">1） 只要覆写 equals，就必须覆写 hashCode。</p><p style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;line-height: 110%;text-align: left;">2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须覆写这两种方法。</p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 19pt;text-align: left;">3） 如果自定义对象作为 Map 的键，那么必须覆写hashCode 和 equals。</p><p class="s27" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">说明：<span style=" color: #333;">String 因为覆写了 hashCode 和 equals 方法，所以可以愉快地将 String 对象作为 key 来使用。</span></p><p class="s2" style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">2. <span style=" color: #C00000;">【强制】</span><span style=" color: #333;">判断所有集合内部的元素是否为空，使用 isEmpty()方法，而不是 size()==0 的方式。</span></p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 110%;text-align: left;">说明：<span style=" color: #333;">在某些集合中，前者的时间复杂度为 O(1)，而且可读性更好。</span><span style=" color: #009757;">正例：</span></p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span style=" color: #000;">Map</span>&lt;<span style=" color: #DD4968;">String</span>, <span style=" color: #DD4968;">Object</span>&gt; <span style=" color: #000;">map </span><span style=" color: #A67E58;">= </span><span style=" color: #07A;">new </span><span style=" color: #000;">HashMap</span><span style=" color: #A67E58;">&lt;&gt;</span>(16);</p><p class="s30" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: left;"><span style=" color: #07A;">if</span>(<span style=" color: #000;">map</span>.<span style=" color: #DD4968;">isEmpty</span>()) {</p><p class="s30" style="padding-top: 4pt;padding-left: 90pt;text-indent: 0pt;text-align: left;"><span style=" color: #000;">System</span>.<span style=" color: #000;">out</span>.<span style=" color: #DD4968;">println</span>(<span style=" color: #50A04F;">&quot;no element in this map.&quot;</span>);</p><p class="s30" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">}</p><p class="s50" style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">3. <span style=" color: #C00000;">【强制】</span><span style=" color: #333;">在使用 java.util.stream.Collectors 类的 toMap()方法转为 Map 集合时，一定要使用含有参数类型为 BinaryOperator，参数名为 mergeFunction 的方法，否则当出现相同 key值时会抛出 IllegalStateException 异常。</span></p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 109%;text-align: justify;">说明：<span style=" color: #333;">参数 mergeFunction 的作用是当出现 key 重复时，自定义对 value 的处理策略。</span><span style=" color: #009757;">正例：</span></p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 84%;text-align: left;"><span style=" color: #000;">List</span><span style=" color: #A67E58;">&lt;</span><span style=" color: #000;">Pair</span>&lt;<span style=" color: #DD4968;">String</span>, <span style=" color: #DD4968;">Double</span>&gt;<span style=" color: #A67E58;">&gt; </span><span style=" color: #000;">pairArrayList </span><span style=" color: #A67E58;">= </span><span style=" color: #07A;">new </span><span style=" color: #000;">ArrayList</span><span style=" color: #A67E58;">&lt;&gt;</span>(<span style=" color: #976800;">3</span>); <span style=" color: #000;">pairArrayList</span>.<span style=" color: #DD4968;">add</span>(<span style=" color: #07A;">new </span><span style=" color: #000;">Pair</span><span style=" color: #A67E58;">&lt;&gt;</span>(<span style=" color: #50A04F;">&quot;version&quot;</span>, <span style=" color: #976800;">12.10</span>));</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span style=" color: #000;">pairArrayList</span>.<span style=" color: #DD4968;">add</span>(<span style=" color: #07A;">new </span><span style=" color: #000;">Pair</span><span style=" color: #A67E58;">&lt;&gt;</span>(<span style=" color: #50A04F;">&quot;version&quot;</span>, <span style=" color: #976800;">12.19</span>));</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 84%;text-align: left;"><span style=" color: #000;">pairArrayList</span>.<span style=" color: #DD4968;">add</span>(<span style=" color: #07A;">new </span><span style=" color: #000;">Pair</span><span style=" color: #A67E58;">&lt;&gt;</span>(<span style=" color: #50A04F;">&quot;version&quot;</span>, <span style=" color: #976800;">6.28</span>)); <span style=" color: #000;">Map</span>&lt;<span style=" color: #DD4968;">String</span>, <span style=" color: #DD4968;">Double</span>&gt; <span style=" color: #000;">map </span><span style=" color: #A67E58;">= </span><span style=" color: #000;">pairArrayList</span>.<span style=" color: #DD4968;">stream</span>().<span style=" color: #DD4968;">collect</span>(</p><p class="s29" style="padding-left: 54pt;text-indent: 0pt;line-height: 84%;text-align: left;"><span style=" color: #6F8090;">// 生成的 map 集合中只有一个键值对：{version=6.28} </span>Collectors<span style=" color: #999;">.</span><span style=" color: #DD4968;">toMap</span><span style=" color: #999;">(</span>Pair<span style=" color: #A67E58;">::</span>getKey<span style=" color: #999;">, </span>Pair<span style=" color: #A67E58;">::</span>getValue<span style=" color: #999;">, (</span>v1<span style=" color: #999;">, </span>v2<span style=" color: #999;">) </span><span style=" color: #A67E58;">-&gt; </span>v2<span style=" color: #999;">));</span></p><p class="s18" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">反例：</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span style=" color: #000;">String</span>[] <span style=" color: #000;">departments </span><span style=" color: #A67E58;">= </span><span style=" color: #07A;">new </span><span style=" color: #000;">String</span>[] {<span style=" color: #50A04F;">&quot;iERP&quot;</span>, <span style=" color: #50A04F;">&quot;iERP&quot;</span>, <span style=" color: #50A04F;">&quot;EIBU&quot;</span>};</p><p class="s31" style="padding-left: 54pt;text-indent: 0pt;line-height: 14pt;text-align: left;">// 抛出 IllegalStateException 异常</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span style=" color: #000;">Map</span>&lt;<span style=" color: #DD4968;">Integer</span>, <span style=" color: #DD4968;">String</span>&gt; <span style=" color: #000;">map </span><span style=" color: #A67E58;">= </span><span style=" color: #000;">Arrays</span>.<span style=" color: #DD4968;">stream</span>(<span style=" color: #000;">departments</span>)</p><p class="s30" style="padding-left: 72pt;text-indent: 0pt;line-height: 15pt;text-align: left;">.<span style=" color: #DD4968;">collect</span>(<span style=" color: #000;">Collectors</span>.<span style=" color: #DD4968;">toMap</span>(<span style=" color: #000;">String</span><span style=" color: #A67E58;">::</span><span style=" color: #000;">hashCode</span>, <span style=" color: #000;">str </span><span style=" color: #A67E58;">-&gt; </span><span style=" color: #000;">str</span>));</p><p class="s9" style="padding-top: 6pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">4. <span style=" color: #C00000;">【强制】</span>在使用 java.util.stream.Collectors 类的 toMap()方法转为 Map 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 19pt;text-align: left;">说明：<span style=" color: #333;">在 java.util.HashMap 的 merge 方法里会进行如下的判断：</span></p><p class="s29" style="padding-left: 72pt;text-indent: -18pt;text-align: left;"><span style=" color: #07A;">if </span><span style=" color: #999;">(</span>value <span style=" color: #A67E58;">== </span>null <span style=" color: #A67E58;">|| </span>remappingFunction <span style=" color: #A67E58;">== </span>null<span style=" color: #999;">) </span><span style=" color: #07A;">throw new </span>NullPointerException<span style=" color: #999;">();</span></p><p class="s18" style="padding-top: 3pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">反例：</p><p class="s30" style="padding-top: 2pt;padding-left: 54pt;text-indent: 0pt;line-height: 84%;text-align: left;"><span style=" color: #000;">List</span><span style=" color: #A67E58;">&lt;</span><span style=" color: #000;">Pair</span>&lt;<span style=" color: #DD4968;">String</span>, <span style=" color: #DD4968;">Double</span>&gt;<span style=" color: #A67E58;">&gt; </span><span style=" color: #000;">pairArrayList </span><span style=" color: #A67E58;">= </span><span style=" color: #07A;">new </span><span style=" color: #000;">ArrayList</span><span style=" color: #A67E58;">&lt;&gt;</span>(<span style=" color: #976800;">2</span>); <span style=" color: #000;">pairArrayList</span>.<span style=" color: #DD4968;">add</span>(<span style=" color: #07A;">new </span><span style=" color: #000;">Pair</span><span style=" color: #A67E58;">&lt;&gt;</span>(<span style=" color: #50A04F;">&quot;version1&quot;</span>, <span style=" color: #976800;">8.3</span>)); <span style=" color: #000;">pairArrayList</span>.<span style=" color: #DD4968;">add</span>(<span style=" color: #07A;">new </span><span style=" color: #000;">Pair</span><span style=" color: #A67E58;">&lt;&gt;</span>(<span style=" color: #50A04F;">&quot;version2&quot;</span>, <span style=" color: #000;">null</span>));</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span style=" color: #000;">Map</span>&lt;<span style=" color: #DD4968;">String</span>, <span style=" color: #DD4968;">Double</span>&gt; <span style=" color: #000;">map </span><span style=" color: #A67E58;">= </span><span style=" color: #000;">pairArrayList</span>.<span style=" color: #DD4968;">stream</span>().<span style=" color: #DD4968;">collect</span>(</p><p class="s31" style="padding-left: 54pt;text-indent: 0pt;line-height: 15pt;text-align: left;">// 抛出 NullPointerException 异常</p><p class="s29" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">Collectors<span style=" color: #999;">.</span><span style=" color: #DD4968;">toMap</span><span style=" color: #999;">(</span>Pair<span style=" color: #A67E58;">::</span>getKey<span style=" color: #999;">, </span>Pair<span style=" color: #A67E58;">::</span>getValue<span style=" color: #999;">, (</span>v1<span style=" color: #999;">, </span>v2<span style=" color: #999;">) </span><span style=" color: #A67E58;">-&gt; </span>v2<span style=" color: #999;">));</span></p><p class="s9" style="padding-top: 9pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">5. <span style=" color: #C00000;">【强制】</span>ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 <span class="s12">ClassCastException </span>异常：<span class="s12">java.util.RandomAccessSubList cannot be cast to java.util.ArrayList</span>。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 110%;text-align: left;">说明：<span style=" color: #333;">subList()返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 本身，而是ArrayList 的一个视图，对于 SubList 的所有操作最终会反映到原列表上。</span></p><p class="s51" style="padding-top: 6pt;padding-left: 42pt;text-indent: -18pt;text-align: left;"><span class="s9">6. </span><span class="s3">【强制】</span><span class="s25">使用 </span>Map <span class="s25">的方法 </span><span class="s52">keySet()</span>/<span class="s52">values()</span>/<span class="s52">entrySet()</span><span class="s25">返回集合对象时，不可以对其进行添加元素操作，否则会抛出 </span>UnsupportedOperationException <span class="s25">异常。</span></p><p class="s25" style="padding-top: 7pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">7. <span style=" color: #C00000;">【强制】</span><span class="s51">Collections </span>类返回的对象，如：<span class="s52">emptyList()</span><span class="s51">/</span><span class="s52">singletonList()</span>等都是 <span class="s51">immutable list</span>，不可对其进行添加或者删除元素的操作。</p><p class="s26" style="padding-left: 42pt;text-indent: 0pt;line-height: 110%;text-align: left;"><span style=" color: #FF4500;">反例：</span>如果查询无结果，返回 <span class="s53">Collections.emptyList()</span>空集合对象，调用方一旦进行了添加元素的操作，就会触发 <span class="s53">UnsupportedOperationException </span>异常。</p><p class="s9" style="padding-top: 3pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">8. <span style=" color: #C00000;">【强制】</span>在 subList 场景中，<span style=" color: #00F;">高度注意</span>对父集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 <span class="s51">ConcurrentModificationException </span>异常。</p><p class="s25" style="padding-top: 7pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">9. <span style=" color: #C00000;">【强制】</span><span style=" color: #333;">使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组。</span></p><p class="s26" style="padding-left: 42pt;text-indent: 0pt;line-height: 110%;text-align: left;"><span style=" color: #FF4500;">反例：</span>直接使用 <span class="s53">toArray </span>无参方法存在问题，此方法返回值只能是 <span class="s53">Object[]</span>类，若强转其它类型数组将出现 <span class="s53">ClassCastException </span>错误。</p><p class="s24" style="padding-left: 42pt;text-indent: 0pt;line-height: 19pt;text-align: left;">正例：</p><p class="s30" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;line-height: 85%;text-align: left;"><span style=" color: #000;">List</span>&lt;<span style=" color: #DD4968;">String</span>&gt; <span style=" color: #000;">list </span><span style=" color: #A67E58;">= </span><span style=" color: #07A;">new </span><span style=" color: #000;">ArrayList</span><span style=" color: #A67E58;">&lt;&gt;</span>(<span style=" color: #976800;">2</span>); <span style=" color: #000;">list</span>.<span style=" color: #DD4968;">add</span>(<span style=" color: #50A04F;">&quot;guan&quot;</span>);</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span style=" color: #000;">list</span>.<span style=" color: #DD4968;">add</span>(<span style=" color: #50A04F;">&quot;bao&quot;</span>);</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;text-align: left;"><span style=" color: #000;">String</span>[] <span style=" color: #000;">array </span><span style=" color: #A67E58;">= </span><span style=" color: #000;">list</span>.<span style=" color: #DD4968;">toArray</span>(<span style=" color: #07A;">new </span><span style=" color: #000;">String</span>[<span style=" color: #976800;">0</span>]);</p><p class="s26" style="padding-top: 3pt;padding-left: 69pt;text-indent: -26pt;line-height: 109%;text-align: left;"><span style=" color: #967B00;">说明：</span>使用 <span class="s53">toArray </span>带参方法，数组空间大小的 <span class="s53">length</span>： <span class="s53">1</span>） <span style=" color: #00F;">等于 </span><span class="s54">0</span>，动态创建与 <span class="s53">size </span>相同的数组，性能最好。</p><p class="s26" style="padding-left: 69pt;text-indent: 0pt;text-align: left;"><span class="s53">2</span>） <span style=" color: #00F;">大于 </span><span class="s54">0 </span><span style=" color: #00F;">但小于</span><span class="s54">size</span>，重新创建大小等于 <span class="s53">size </span>的数组，增加 <span class="s53">GC </span>负担。</p><p class="s26" style="padding-top: 1pt;padding-left: 69pt;text-indent: 0pt;text-align: left;"><span class="s53">3</span>） <span style=" color: #00F;">等于 </span><span class="s54">size</span>，在高并发情况下，数组创建完成之后，<span class="s53">size </span>正在变大的情况下，负面影响与 2 相同。</p><p class="s26" style="padding-top: 1pt;padding-left: 69pt;text-indent: 0pt;text-align: left;"><span class="s53">4</span>） <span style=" color: #00F;">大于 </span><span class="s54">size</span>，空间浪费，且在 <span class="s53">size </span>处插入 <span class="s53">null </span>值，存在 <span class="s53">NPE </span>隐患。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-left: 42pt;text-indent: -18pt;text-align: left;">10. <span style=" color: #C00000;">【强制】</span><span style=" color: #23292D;">在使用 Collection 接口任何实现类的 addAll()方法时，都要对输入的集合参数进行 NPE 判断。</span></p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 110%;text-align: left;">说明：<span style=" color: #23292D;">在 ArrayList#addAll 方法的第一行代码即 Object[] a = c.toArray(); 其中 c 为输入集合参数，如果为 null，则直接抛出异常。</span></p><p class="s9" style="padding-top: 6pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">11. <span style=" color: #C00000;">【强制】</span>使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 110%;text-align: left;">说明：<span style=" color: #333;">asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。</span></p><p class="s43" style="padding-top: 1pt;padding-left: 60pt;text-indent: 0pt;line-height: 127%;text-align: left;">String[] str = new String[] { &quot;chen&quot;, &quot;yang&quot;, &quot;hao&quot; }; List list = Arrays.asList(str);</p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 18pt;text-align: left;">第一种情况：list.add(&quot;yangguanbao&quot;); 运行时异常。</p><p style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">第二种情况：str[0] = &quot;change&quot;; <span style=" color: #23292D;">也会随之修改，反之亦然。</span></p><p class="s9" style="padding-top: 8pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">12. <span style=" color: #C00000;">【强制】</span>泛型通配符<span class="s55">&lt;? extends T&gt;</span>来接收返回的数据，此写法的泛型集合不能使用 <span class="s55">add </span>方法，而<span class="s55">&lt;? super T&gt;</span>不能使用 <span class="s55">get </span>方法，两者在接口调用赋值的场景中容易出错。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">说明：<span style=" color: #333;">扩展说一下 PECS(Producer Extends Consumer Super)原则：第一、频繁往外读取内容的，适合用</span></p><p style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">&lt;? extends T&gt;。第二、经常往里插入的，适合用&lt;? super T&gt;</p><p class="s9" style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;line-height: 22pt;text-align: left;">13. <span style=" color: #C00000;">【强制】</span><span style=" color: #23292D;">在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行</span></p><p class="s25" style="padding-left: 42pt;text-indent: 0pt;line-height: 22pt;text-align: left;">instanceof 判断，避免抛出 ClassCastException 异常。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">说明：<span style=" color: #23292D;">毕竟泛型是在 JDK5 后才出现，考虑到向前兼容，编译器是允许非泛型集合与泛型集合互相赋值。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s18" style="padding-top: 2pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">反例：</p><p class="s29" style="padding-top: 7pt;padding-left: 54pt;text-indent: 0pt;line-height: 15pt;text-align: left;">List<span style=" color: #A67E58;">&lt;</span>String<span style=" color: #A67E58;">&gt; </span>generics <span style=" color: #A67E58;">= </span>null<span style=" color: #999;">;</span></p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 84%;text-align: left;"><span style=" color: #000;">List notGenerics </span><span style=" color: #A67E58;">= </span><span style=" color: #07A;">new </span><span style=" color: #000;">ArrayList</span>(<span style=" color: #990054;">10</span>); <span style=" color: #000;">notGenerics</span>.<span style=" color: #DD4968;">add</span>(<span style=" color: #07A;">new </span><span style=" color: #000;">Object</span>()); <span style=" color: #000;">notGenerics</span>.<span style=" color: #DD4968;">add</span>(<span style=" color: #07A;">new </span><span style=" color: #000;">Integer</span>(<span style=" color: #990054;">1</span>)); <span style=" color: #000;">generics </span><span style=" color: #A67E58;">= </span><span style=" color: #000;">notGenerics</span>;</p><p class="s31" style="padding-left: 54pt;text-indent: 0pt;line-height: 14pt;text-align: left;">// 此处抛出 ClassCastException 异常</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span style=" color: #000;">String string </span><span style=" color: #A67E58;">= </span><span style=" color: #000;">generics</span>.<span style=" color: #DD4968;">get</span>(<span style=" color: #990054;">0</span>);</p><p class="s9" style="padding-top: 3pt;padding-left: 24pt;text-indent: 0pt;line-height: 22pt;text-align: left;">14. <span style=" color: #C00000;">【强制】</span>不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator</p><p class="s9" style="padding-left: 42pt;text-indent: 0pt;line-height: 22pt;text-align: left;">方式，如果并发操作，需要对 Iterator 对象加锁。</p><p class="s24" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">正例：</p><p class="s30" style="padding-top: 2pt;padding-left: 54pt;text-indent: 0pt;line-height: 84%;text-align: left;"><span style=" color: #000;">List</span>&lt;<span style=" color: #DD4968;">String</span>&gt; <span style=" color: #000;">list </span><span style=" color: #A67E58;">= </span><span style=" color: #07A;">new </span><span style=" color: #000;">ArrayList</span><span style=" color: #A67E58;">&lt;&gt;</span>(); <span style=" color: #000;">list</span>.<span style=" color: #DD4968;">add</span>(<span style=" color: #50A04F;">&quot;1&quot;</span>);</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span style=" color: #000;">list</span>.<span style=" color: #DD4968;">add</span>(<span style=" color: #50A04F;">&quot;2&quot;</span>);</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 84%;text-align: left;"><span style=" color: #000;">Iterator</span>&lt;<span style=" color: #DD4968;">String</span>&gt; <span style=" color: #000;">iterator </span><span style=" color: #A67E58;">= </span><span style=" color: #000;">list</span>.<span style=" color: #DD4968;">iterator</span>(); <span style=" color: #07A;">while </span>(<span style=" color: #000;">iterator</span>.<span style=" color: #DD4968;">hasNext</span>()) {</p><p class="s30" style="padding-left: 72pt;text-indent: 0pt;line-height: 84%;text-align: left;"><span style=" color: #000;">String item </span><span style=" color: #A67E58;">= </span><span style=" color: #000;">iterator</span>.<span style=" color: #DD4968;">next</span>(); <span style=" color: #07A;">if </span>(<span style=" color: #000;">删除元素的条件</span>) {</p><p class="s30" style="padding-left: 90pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span style=" color: #000;">iterator</span>.<span style=" color: #DD4968;">remove</span>();</p><p class="s30" style="padding-left: 72pt;text-indent: 0pt;line-height: 13pt;text-align: left;">}</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 15pt;text-align: left;">}</p><p class="s18" style="padding-left: 43pt;text-indent: 0pt;line-height: 19pt;text-align: left;">反例：</p><p class="s29" style="padding-left: 54pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span style=" color: #07A;">for </span><span style=" color: #999;">(</span>String item <span style=" color: #A67E58;">: </span>list<span style=" color: #999;">) {</span></p><p class="s30" style="padding-left: 90pt;text-indent: -18pt;line-height: 84%;text-align: left;"><span style=" color: #07A;">if </span>(<span style=" color: #50A04F;">&quot;1&quot;</span>.<span style=" color: #DD4968;">equals</span>(<span style=" color: #000;">item</span>)) { <span style=" color: #000;">list</span>.<span style=" color: #DD4968;">remove</span>(<span style=" color: #000;">item</span>);</p><p class="s30" style="padding-left: 72pt;text-indent: 0pt;line-height: 14pt;text-align: left;">}</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 15pt;text-align: left;">}</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 19pt;text-align: left;">说明：<span style=" color: #333;">以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？</span></p><p class="s9" style="padding-top: 11pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">15. <span style=" color: #C00000;">【强制】</span>在 <span class="s12">JDK</span>7 版本及以上，<span class="s12">Comparator </span>实现类要满足如下三个条件，不然 <span class="s12">Arrays</span>.<span class="s12">sort</span>， <span class="s12">Collections</span>.<span class="s12">sort </span>会抛 <span class="s12">IllegalArgumentException </span>异常。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">说明：<span style=" color: #333;">三个条件如下</span></p><p style="padding-top: 1pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">1） x，y 的比较结果和 y，x 的比较结果相反。</p><p style="padding-top: 1pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">2） x&gt;y，y&gt;z，则 x&gt;z。</p><p style="padding-top: 1pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">3） x=y，则 x，z 比较结果和 y，z 比较结果相同。</p><p class="s18" style="padding-top: 1pt;padding-left: 53pt;text-indent: -11pt;line-height: 110%;text-align: left;">反例：<span style=" color: #333;">下例中没有处理相等的情况，交换两个对象判断结果并不互反，不符合第一个条件，在实际使用中可能会出现异常。</span></p><p class="s30" style="padding-left: 72pt;text-indent: -18pt;line-height: 84%;text-align: left;"><span style=" color: #07A;">new </span><span style=" color: #000;">Comparator</span>&lt;<span style=" color: #DD4968;">Student</span>&gt;() { @Override</p><p class="s30" style="padding-left: 90pt;text-indent: -18pt;line-height: 84%;text-align: left;"><span style=" color: #07A;">public int </span><span style=" color: #DD4968;">compare</span>(<span style=" color: #000;">Student o1</span>, <span style=" color: #000;">Student o2</span>) { <span style=" color: #07A;">return </span><span style=" color: #000;">o1</span>.<span style=" color: #DD4968;">getId</span>() <span style=" color: #A67E58;">&gt; </span><span style=" color: #000;">o2</span>.<span style=" color: #DD4968;">getId</span>() <span style=" color: #A67E58;">? </span><span style=" color: #976800;">1 </span><span style=" color: #A67E58;">: -</span><span style=" color: #976800;">1</span>;</p><p class="s30" style="padding-left: 72pt;text-indent: 0pt;line-height: 15pt;text-align: left;">}</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">16. <span style=" color: #FFC000;">【推荐】</span>集合泛型定义时，在 JDK7 及以上，使用 diamond 语法或全省略。</p><p class="s27" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">说明：<span style=" color: #333;">菱形泛型，即 diamond，直接使用&lt;&gt;来指代前边已经指定的类型。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s24" style="padding-top: 2pt;padding-left: 38pt;text-indent: 0pt;line-height: 19pt;text-align: left;">正例：</p><p class="s31" style="padding-left: 54pt;text-indent: 0pt;line-height: 15pt;text-align: left;">// diamond 方式，即&lt;&gt;</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span style=" color: #000;">HashMap</span>&lt;<span style=" color: #DD4968;">String</span>, <span style=" color: #DD4968;">String</span>&gt; <span style=" color: #000;">userCache </span><span style=" color: #A67E58;">= </span><span style=" color: #07A;">new </span><span style=" color: #000;">HashMap</span><span style=" color: #A67E58;">&lt;&gt;</span>(<span style=" color: #976800;">16</span>);</p><p class="s31" style="padding-left: 54pt;text-indent: 0pt;line-height: 14pt;text-align: left;">// 全省略方式</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span style=" color: #000;">ArrayList</span>&lt;<span style=" color: #DD4968;">User</span>&gt; <span style=" color: #000;">users </span><span style=" color: #A67E58;">= </span><span style=" color: #07A;">new </span><span style=" color: #000;">ArrayList</span>(<span style=" color: #976800;">10</span>);</p><p class="s9" style="padding-left: 24pt;text-indent: 0pt;line-height: 21pt;text-align: justify;">17. <span style=" color: #FFC000;">【推荐】</span>集合初始化时，指定集合初始值大小。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 109%;text-align: justify;">说明：<span style=" color: #333;">HashMap 使用 HashMap(int initialCapacity) 初始化，如果暂时无法确定集合大小，那么指定默认值（16）即可。</span></p><p class="s24" style="padding-left: 42pt;text-indent: 0pt;line-height: 110%;text-align: justify;">正例：<span style=" color: #333;">initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loader factor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。</span></p><p class="s18" style="padding-left: 42pt;text-indent: 0pt;line-height: 109%;text-align: justify;">反例： <span style=" color: #333;">HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素增加而被迫不断扩容， resize()方法总共会调用 8 次，反复重建哈希表和数据迁移。当放置的集合元素个数达千万级时会影响程序性能。</span></p><p class="s9" style="padding-top: 5pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">18. <span style=" color: #FFC000;">【推荐】</span>使用 <span class="s12">entrySet </span>遍历 <span class="s12">Map </span>类集合 <span class="s12">KV</span>，而不是 <span class="s12">keySet </span>方式进行遍历。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 109%;text-align: justify;">说明：<span style=" color: #333;">keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.forEach 方法。</span></p><p class="s24" style="padding-left: 42pt;text-indent: 0pt;line-height: 110%;text-align: justify;">正例：<span style=" color: #333;">values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是K 值集合，是一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合。</span></p><p class="s9" style="padding-top: 5pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">19. <span style=" color: #FFC000;">【推荐】</span>高度注意 Map 类集合 K/V 能不能存储null 值的情况，如下表格：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:44.9pt" cellspacing="0"><tr style="height:31pt"><td style="width:107pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s56" style="padding-top: 6pt;padding-left: 38pt;padding-right: 36pt;text-indent: 0pt;text-align: center;">集合类</p></td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s56" style="padding-top: 6pt;padding-left: 26pt;padding-right: 25pt;text-indent: 0pt;text-align: center;">Key</p></td><td style="width:72pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s56" style="padding-top: 6pt;padding-left: 22pt;text-indent: 0pt;text-align: left;">Value</p></td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s56" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Super</p></td><td style="width:122pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s56" style="padding-top: 6pt;padding-left: 50pt;padding-right: 49pt;text-indent: 0pt;text-align: center;">说明</p></td></tr><tr style="height:30pt"><td style="width:107pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s14" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">Hashtable</p></td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s57" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">不允许为 null</p></td><td style="width:72pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s57" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">不允许为 null</p></td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s14" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">Dictionary</p></td><td style="width:122pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s14" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">线程安全</p></td></tr><tr style="height:31pt"><td style="width:107pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s14" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">ConcurrentHashMap</p></td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s57" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">不允许为 null</p></td><td style="width:72pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s57" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">不允许为 null</p></td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s14" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">AbstractMap</p></td><td style="width:122pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s14" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">锁分段技术（JDK8:CAS）</p></td></tr><tr style="height:31pt"><td style="width:107pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s14" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">TreeMap</p></td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s58" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">不允许为 null</p></td><td style="width:72pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s59" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">允许为 null</p></td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s14" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">AbstractMap</p></td><td style="width:122pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s14" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">线程不安全</p></td></tr><tr style="height:30pt"><td style="width:107pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s14" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">HashMap</p></td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s59" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">允许为 null</p></td><td style="width:72pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s59" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">允许为 null</p></td><td style="width:73pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s14" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">AbstractMap</p></td><td style="width:122pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s14" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">线程不安全</p></td></tr></table><p class="s18" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">反例：<span style=" color: #333;">由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上，存储</span></p><p style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">null 值时会抛出 NPE 异常。</p><p class="s9" style="padding-top: 8pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">20. <span style=" color: #76923B;">【参考】</span>合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 109%;text-align: left;">说明：<span style=" color: #333;">有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是 order/sort。</span></p><p class="s9" style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 22pt;text-align: left;">21. <span style=" color: #76923B;">【参考】</span>利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的</p><p class="s9" style="padding-left: 42pt;text-indent: 0pt;line-height: 22pt;text-align: left;">contains()进行遍历去重或者判断包含操作。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part8.htm">&lt; 上一个</a><span> | </span><a href="../阿里云嵩山版Java开发手册.html">内容</a><span> | </span><a href="part10.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
