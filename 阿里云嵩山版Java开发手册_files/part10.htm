<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>(七) 并发处理</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part9.htm">&lt; 上一个</a><span> | </span><a href="../阿里云嵩山版Java开发手册.html">内容</a><span> | </span><a href="part11.htm">下一个 &gt;</a></p><p class="s16" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark9">(七) 并发处理</a><a name="bookmark21">&zwnj;</a></p><p class="s9" style="padding-top: 4pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">1. <span style=" color: #C00000;">【强制】</span>获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">说明：<span style=" color: #333;">资源驱动类、工具类、单例工厂类都需要注意。</span></p><p class="s9" style="padding-top: 7pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">2. <span style=" color: #C00000;">【强制】</span>创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</p><p class="s24" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">正例：<span style=" color: #23292D;">自定义线程工厂，并且根据外部特征进行分组，比如，来自同一机房的调用，把机房编号赋值给</span></p><p class="s26" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;line-height: 19pt;text-align: left;">whatFeatureOfGroup</p><p class="s28" style="padding-top: 1pt;padding-left: 72pt;text-indent: -18pt;line-height: 85%;text-align: left;">public class <span style=" color: #000;">UserThreadFactory </span>implements <span style=" color: #000;">ThreadFactory </span><span style=" color: #999;">{ </span>private final <span style=" color: #000;">String namePrefix</span><span style=" color: #999;">;</span></p><p class="s28" style="padding-left: 72pt;text-indent: 0pt;line-height: 15pt;text-align: left;">private final <span style=" color: #000;">AtomicInteger nextId </span><span style=" color: #A67E58;">= </span>new <span style=" color: #000;">AtomicInteger</span><span style=" color: #999;">(</span><span style=" color: #976800;">1</span><span style=" color: #999;">);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 72pt;text-indent: 0pt;line-height: 15pt;text-align: left;">// 定义线程组名称，在利用 jstack 来排查问题时，非常有帮助</p><p class="s30" style="padding-left: 72pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span style=" color: #DD4968;">UserThreadFactory</span>(<span style=" color: #000;">String whatFeatureOfGroup</span>) {</p><p class="s33" style="padding-left: 90pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span style=" color: #000;">namePrefix </span>= <span style=" color: #50A04F;">&quot;From UserThreadFactory&#39;s &quot; </span>+ <span style=" color: #000;">whatFeatureOfGroup </span>+ <span style=" color: #50A04F;">&quot;-Worker-&quot;</span><span style=" color: #999;">;</span></p><p class="s30" style="padding-left: 72pt;text-indent: 0pt;line-height: 14pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s30" style="padding-left: 72pt;text-indent: 0pt;line-height: 15pt;text-align: left;">@Override</p><p class="s29" style="padding-left: 72pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span style=" color: #07A;">public </span>Thread <span style=" color: #DD4968;">newThread</span><span style=" color: #999;">(</span>Runnable task<span style=" color: #999;">) {</span></p><p class="s30" style="padding-left: 90pt;text-indent: 0pt;line-height: 84%;text-align: justify;"><span style=" color: #000;">String name </span><span style=" color: #A67E58;">= </span><span style=" color: #000;">namePrefix </span><span style=" color: #A67E58;">+ </span><span style=" color: #000;">nextId</span>.<span style=" color: #DD4968;">getAndIncrement</span>(); <span style=" color: #000;">Thread thread </span><span style=" color: #A67E58;">= </span><span style=" color: #07A;">new </span><span style=" color: #000;">Thread</span>(<span style=" color: #000;">null</span>, <span style=" color: #000;">task</span>, <span style=" color: #000;">name</span>, <span style=" color: #976800;">0</span>, <span style=" color: #0084BA;">false</span>); <span style=" color: #000;">System</span>.<span style=" color: #000;">out</span>.<span style=" color: #DD4968;">println</span>(<span style=" color: #000;">thread</span>.<span style=" color: #DD4968;">getName</span>());</p><p class="s28" style="padding-left: 90pt;text-indent: 0pt;line-height: 15pt;text-align: justify;">return <span style=" color: #000;">thread</span><span style=" color: #999;">;</span></p><p class="s30" style="padding-left: 72pt;text-indent: 0pt;line-height: 14pt;text-align: left;">}</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">3. <span style=" color: #C00000;">【强制】</span>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 110%;text-align: left;">说明：<span style=" color: #333;">线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</span></p><p class="s9" style="padding-top: 9pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">4. <span style=" color: #C00000;">【强制】</span>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">说明：<span style=" color: #333;">Executors 返回的线程池对象的弊端如下：</span></p><p style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">1） <span style=" color: #C6244E;">FixedThreadPool </span>和 <span style=" color: #C6244E;">SingleThreadPool</span>：</p><p style="padding-top: 1pt;padding-left: 42pt;text-indent: 10pt;line-height: 110%;text-align: left;">允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 2） <span style=" color: #C6244E;">CachedThreadPool</span>：</p><p style="padding-left: 53pt;text-indent: 0pt;line-height: 19pt;text-align: left;">允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p><p class="s9" style="padding-top: 8pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">5. <span style=" color: #C00000;">【强制】</span><span class="s12">SimpleDateFormat </span>是线程不安全的类，一般不要定义为 <span class="s12">static </span>变量，如果定义为 <span class="s12">static</span>，必须加锁，或者使用 <span class="s12">DateUtils </span>工具类。</p><p class="s24" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">正例：<span style=" color: #333;">注意线程安全，使用 DateUtils。亦推荐如下处理：</span></p><p class="s30" style="padding-top: 2pt;padding-left: 72pt;text-indent: -18pt;line-height: 84%;text-align: left;"><span style=" color: #07A;">private static final </span><span style=" color: #000;">ThreadLocal</span>&lt;<span style=" color: #DD4968;">DateFormat</span>&gt; <span style=" color: #000;">df </span><span style=" color: #A67E58;">= </span><span style=" color: #07A;">new </span><span style=" color: #000;">ThreadLocal</span>&lt;<span style=" color: #DD4968;">DateFormat</span>&gt;() { @Override</p><p class="s28" style="padding-left: 72pt;text-indent: 0pt;line-height: 14pt;text-align: left;">protected <span style=" color: #000;">DateFormat </span><span style=" color: #DD4968;">initialValue</span><span style=" color: #999;">() {</span></p><p class="s30" style="padding-left: 90pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span style=" color: #07A;">return new </span><span style=" color: #000;">SimpleDateFormat</span>(<span style=" color: #50A04F;">&quot;yyyy-MM-dd&quot;</span>);</p><p class="s30" style="padding-left: 72pt;text-indent: 0pt;line-height: 13pt;text-align: left;">}</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 15pt;text-align: left;">};</p><p class="s27" style="padding-top: 4pt;padding-left: 42pt;text-indent: 0pt;line-height: 109%;text-align: left;">说明：<span style=" color: #333;">如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar， DateTimeFormatter 代替 SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe。</span></p><p class="s9" style="padding-top: 6pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">6. <span style=" color: #C00000;">【强制】</span>必须回收自定义的 ThreadLocal 变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 try-finally 块进行回收。</p><p class="s24" style="padding-left: 42pt;text-indent: 0pt;line-height: 19pt;text-align: left;">正例：</p><p class="s30" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;line-height: 85%;text-align: left;"><span style=" color: #000;">objectThreadLocal</span>.<span style=" color: #DD4968;">set</span>(<span style=" color: #000;">userInfo</span>); <span style=" color: #07A;">try </span>{</p><p class="s31" style="text-indent: 0pt;line-height: 13pt;text-align: right;">// ...</p><p class="s30" style="text-indent: 0pt;line-height: 14pt;text-align: right;">} <span style=" color: #07A;">finally </span>{</p><p class="s30" style="padding-left: 72pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span style=" color: #000;">objectThreadLocal</span>.<span style=" color: #DD4968;">remove</span>();</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">}</p><p class="s9" style="padding-top: 10pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">7. <span style=" color: #C00000;">【强制】</span>高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁<span class="s12">；</span>能锁区块，就不要锁整个方法体<span class="s12">；</span>能用对象锁，就不要用类锁。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">说明：<span style=" color: #333;">尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。</span></p><p class="s9" style="padding-top: 8pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">8. <span style=" color: #C00000;">【强制】</span>对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 109%;text-align: left;">说明：<span style=" color: #333;">线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、 B、C，否则可能出现死锁。</span></p><p class="s25" style="padding-top: 6pt;padding-left: 42pt;text-indent: -18pt;text-align: left;"><span style=" color: #333;">9. </span><span style=" color: #C00000;">【强制】</span>在使用阻塞等待获取锁的方式中，必须在 <span class="s51">try </span>代码块之外，并且在加锁方法与 <span class="s51">try </span>代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 <span class="s51">finally </span>中无法解锁。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 110%;text-align: left;">说明一：<span style=" color: #23292D;">如果在 lock 方法与 try 代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。</span></p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 110%;text-align: left;">说明二：<span style=" color: #23292D;">如果 lock 方法在try 代码块之内，可能由于其它方法抛出异常，导致在 finally 代码块中，unlock对未加锁的对象解锁，它会调用 AQS 的tryRelease 方法（取决于具体实现类），抛出 IllegalMonitorStateException 异常。</span></p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 110%;text-align: left;">说明三：<span style=" color: #23292D;">在 Lock 对象的 lock 方法实现中可能抛出 unchecked 异常，产生的后果与说明二相同。</span><span style=" color: #009757;">正例：</span></p><p class="s29" style="padding-left: 54pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Lock lock <span style=" color: #A67E58;">= </span><span style=" color: #07A;">new </span>XxxLock<span style=" color: #999;">();</span></p><p class="s31" style="padding-left: 54pt;text-indent: 0pt;line-height: 14pt;text-align: left;">// ...</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 84%;text-align: left;"><span style=" color: #000;">lock</span>.<span style=" color: #DD4968;">lock</span>(); <span style=" color: #07A;">try </span>{</p><p class="s32" style="padding-left: 72pt;text-indent: 0pt;line-height: 85%;text-align: left;">doSomething<span style=" color: #999;">(); </span>doOthers<span style=" color: #999;">();</span></p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 13pt;text-align: left;">} <span style=" color: #07A;">finally </span>{</p><p class="s30" style="padding-left: 72pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span style=" color: #000;">lock</span>.<span style=" color: #DD4968;">unlock</span>();</p><p class="s30" style="text-indent: 0pt;line-height: 14pt;text-align: center;">}</p><p class="s18" style="padding-left: 21pt;text-indent: 0pt;line-height: 19pt;text-align: center;">反例：</p><p class="s29" style="padding-left: 54pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Lock lock <span style=" color: #A67E58;">= </span><span style=" color: #07A;">new </span>XxxLock<span style=" color: #999;">();</span></p><p class="s31" style="padding-left: 54pt;text-indent: 0pt;line-height: 15pt;text-align: left;">// ...</p><p class="s28" style="padding-top: 2pt;text-indent: 0pt;text-align: right;">try <span style=" color: #999;">{</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="text-indent: 0pt;line-height: 15pt;text-align: left;">// 如果此处抛出异常，则直接执行 finally 代码块</p><p class="s32" style="text-indent: 0pt;line-height: 14pt;text-align: left;">doSomething<span style=" color: #999;">();</span></p><p class="s31" style="text-indent: 0pt;line-height: 14pt;text-align: left;">// 无论加锁是否成功，finally 代码块都会执行</p><p class="s30" style="text-indent: 0pt;line-height: 84%;text-align: left;"><span style=" color: #000;">lock</span>.<span style=" color: #DD4968;">lock</span>(); <span style=" color: #DD4968;">doOthers</span>();</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 14pt;text-align: left;">} <span style=" color: #07A;">finally </span>{</p><p class="s30" style="padding-left: 72pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span style=" color: #000;">lock</span>.<span style=" color: #DD4968;">unlock</span>();</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 14pt;text-align: left;">}</p><p class="s51" style="padding-top: 10pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">10. <span class="s3">【强制】</span><span class="s25">在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。</span></p><p class="s53" style="padding-left: 42pt;text-indent: 0pt;line-height: 110%;text-align: left;"><span class="s27">说明：</span>Lock <span class="s26">对象的 </span>unlock <span class="s26">方法在执行时，它会调用 </span>AQS <span class="s26">的 </span>tryRelease <span class="s26">方法（取决于具体实现类），如果当前线程不持有锁，则抛出 </span>IllegalMonitorStateException <span class="s26">异常。</span></p><p class="s24" style="padding-left: 42pt;text-indent: 0pt;line-height: 19pt;text-align: left;">正例：</p><p class="s29" style="padding-left: 54pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Lock lock <span style=" color: #A67E58;">= </span><span style=" color: #07A;">new </span>XxxLock<span style=" color: #999;">();</span></p><p class="s31" style="padding-left: 54pt;text-indent: 0pt;line-height: 14pt;text-align: left;">// ...</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 84%;text-align: left;"><span style=" color: #07A;">boolean </span><span style=" color: #000;">isLocked </span><span style=" color: #A67E58;">= </span><span style=" color: #000;">lock</span>.<span style=" color: #DD4968;">tryLock</span>(); <span style=" color: #07A;">if </span>(<span style=" color: #000;">isLocked</span>) {</p><p class="s28" style="padding-left: 72pt;text-indent: 0pt;line-height: 15pt;text-align: left;">try <span style=" color: #999;">{</span></p><p class="s32" style="padding-left: 90pt;text-indent: 0pt;line-height: 84%;text-align: left;">doSomething<span style=" color: #999;">(); </span>doOthers<span style=" color: #999;">();</span></p><p class="s30" style="padding-left: 72pt;text-indent: 0pt;line-height: 14pt;text-align: left;">} <span style=" color: #07A;">finally </span>{</p><p class="s30" style="padding-left: 90pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span style=" color: #000;">lock</span>.<span style=" color: #DD4968;">unlock</span>();</p><p class="s30" style="padding-left: 72pt;text-indent: 0pt;line-height: 13pt;text-align: left;">}</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 15pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 2pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">11. <span style=" color: #C00000;">【强制】</span>并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 <span class="s12">version </span>作为更新依据。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 110%;text-align: justify;">说明：<span style=" color: #333;">如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。</span></p><p class="s9" style="padding-top: 6pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">12. <span style=" color: #C00000;">【强制】</span>多线程并行处理定时任务时，<span class="s12">Timer </span>运行多个 <span class="s12">TimeTask </span>时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 <span class="s12">ScheduledExecutorService </span>则没有这个问题。</p><p class="s9" style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;text-align: justify;">13. <span style=" color: #FFC000;">【推荐】</span><span style=" color: #23292D;">资金相关的金融敏感信息，使用悲观锁策略。</span></p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 109%;text-align: justify;">说明：<span style=" color: #23292D;">乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观锁更新。</span></p><p class="s24" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">正例：<span style=" color: #333;">悲观锁遵循一锁、二判、三更新、四释放的原则。</span></p><p class="s9" style="padding-top: 8pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">14. <span style=" color: #FFC000;">【推荐】</span>使用 <span class="s12">CountDownLatch </span>进行异步转同步操作，每个线程退出前必须调用 <span class="s12">countDown </span>方法，线程执行代码注意 <span class="s12">catch </span>异常，确保 <span class="s12">countDown </span>方法被执行到，避免主线程无法执行至 <span class="s12">await </span>方法，直到超时才返回结果。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">说明：<span style=" color: #333;">注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。</span></p><p class="s9" style="padding-top: 3pt;padding-left: 24pt;text-indent: 0pt;line-height: 22pt;text-align: left;">15. <span style=" color: #FFC000;">【推荐】</span>避免 <span class="s12">Random </span>实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 <span class="s12">seed</span></p><p class="s9" style="padding-left: 42pt;text-indent: 0pt;line-height: 22pt;text-align: left;">导致的性能下降。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">说明：<span style=" color: #333;">Random 实例包括 java.util.Random 的实例或者 Math.random()的方式。</span></p><p class="s24" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;line-height: 109%;text-align: left;">正例：<span style=" color: #333;">在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保证每个线程持有一个单独的 Random 实例。</span></p><p class="s9" style="padding-top: 6pt;padding-left: 42pt;text-indent: -18pt;text-align: justify;">16. <span style=" color: #FFC000;">【推荐】</span>通过双重检查锁<span class="s12">（double</span>-<span class="s12">checked locking）（</span>在并发场景下<span class="s12">）</span>存在延迟初始化的优化问题隐患<span class="s12">（</span>可参考 <span class="s12">The </span>&quot;<span class="s12">Double</span>-<span class="s12">Checked Locking is Broken</span>&quot; <span class="s12">Declaration）</span>，推荐解决方案中较为简单一种<span class="s12">（</span>适用于 <span class="s12">JDK</span>5 及以上版本<span class="s12">）</span>，将目标属性声明为 <span class="s12">volatile </span>型，比如将 helper 的属性声明修改为`private volatile Helper helper = null;`<span class="s12">。</span></p><p class="s24" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">正例：</p><p class="s28" style="padding-left: 54pt;text-indent: 0pt;line-height: 15pt;text-align: left;">public class <span style=" color: #000;">LazyInitDemo </span><span style=" color: #999;">{</span></p><p class="s29" style="padding-left: 72pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span style=" color: #07A;">private </span>volatile Helper helper <span style=" color: #A67E58;">= </span>null<span style=" color: #999;">;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s29" style="padding-left: 90pt;text-indent: -18pt;line-height: 84%;text-align: left;"><span style=" color: #07A;">public </span>Helper <span style=" color: #DD4968;">getHelper</span><span style=" color: #999;">() { </span><span style=" color: #07A;">if </span><span style=" color: #999;">(</span>helper <span style=" color: #A67E58;">== </span>null<span style=" color: #999;">) {</span></p><p class="s28" style="padding-left: 108pt;text-indent: 0pt;line-height: 14pt;text-align: left;">synchronized <span style=" color: #999;">(</span>this<span style=" color: #999;">) {</span></p><p class="s29" style="padding-left: 126pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span style=" color: #07A;">if </span><span style=" color: #999;">(</span>helper <span style=" color: #A67E58;">== </span>null<span style=" color: #999;">) { </span>helper <span style=" color: #A67E58;">= </span><span style=" color: #07A;">new </span>Helper<span style=" color: #999;">(); }</span></p><p class="s30" style="padding-left: 108pt;text-indent: 0pt;line-height: 13pt;text-align: left;">}</p><p class="s30" style="padding-left: 90pt;text-indent: 0pt;line-height: 15pt;text-align: left;">}</p><p class="s28" style="padding-left: 90pt;text-indent: 0pt;line-height: 13pt;text-align: left;">return <span style=" color: #000;">helper</span><span style=" color: #999;">;</span></p><p class="s30" style="padding-left: 72pt;text-indent: 0pt;line-height: 15pt;text-align: left;">}</p><p class="s31" style="padding-left: 72pt;text-indent: 0pt;line-height: 13pt;text-align: left;">// other methods and fields...</p><p class="s30" style="padding-left: 54pt;text-indent: 0pt;line-height: 15pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 2pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">17. <span style=" color: #76923B;">【参考】</span><span class="s12">volatile </span>解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。</p><p class="s27" style="padding-left: 42pt;text-indent: 0pt;line-height: 109%;text-align: left;">说明：<span style=" color: #333;">如果是 count++操作，使用如下类实现：AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是JDK8，推荐使用LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。</span></p><p class="s9" style="padding-top: 6pt;padding-left: 42pt;text-indent: -18pt;text-align: left;">18. <span style=" color: #76923B;">【参考】</span>HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。</p><p class="s9" style="padding-top: 6pt;padding-left: 42pt;text-indent: -18pt;line-height: 107%;text-align: left;">19. <span style=" color: #76923B;">【参考】</span>ThreadLocal 对象使用 static 修饰，ThreadLocal 无法解决共享对象的更新问题。 <span class="s21">说明：</span><span class="s12">这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part9.htm">&lt; 上一个</a><span> | </span><a href="../阿里云嵩山版Java开发手册.html">内容</a><span> | </span><a href="part11.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
